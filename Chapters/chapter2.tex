%!TEX root = ../template.tex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% chapter2.tex
%% NOVA thesis document file
%%
%% Chapter with the template manual
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\typeout{NT FILE chapter2.tex}%

\chapter{Related Work}
\label{cha:related_work}
% TODO add some introduction to this chapter

\section{Gossip Protocol}
\label{sec:gossip_protocol}

\subsection{History and Overview}
\label{subsec:history_overview}
The gossip protocol, as the name indicates, was created based on how gossips are
propagated in social groups. In a gossip protocol, nodes in a network send the
information, randomly, to other nodes in the same network, similar to how a gossip is
spread between members in a social group\cite{Leitao2007}.

The gossip protocol is known as a highly scalable and resilient approach to implement
reliable broadcast. This protocol is based on every participant propagating their messages
collaboratively with all the members of their group.

This process starts when a node desires to propagate some piece of information to the
other members of his network. This node will send his message to \textit{t} nodes,
chosen randomly, (\textit{t} being a parameter called \textit{fanout}, which is better
explaned in the subsection \ref{subsec:parameters}). When the receiving nodes obtain the
message for the first time, they will do the same as the previous node had done and
resend the message to \textit{t}, randomly chosen nodes. If a node receives the same
message twice, it will discard it. When this happens, which may occour quite often,
since the nodes are unaware of which nodes have already received a message, there is
redundancy.

However, since neither node knows who has received each message and who has sent a
message to whom, each node will have to keep a log of all messages that he has already
received.

%TODO types of gossip, rumor mongering, etc (see birman2007)
% TODO
% In order to operate exactly as described above, gossip protocols require each node to maintain information
% concerning the entire system membership, in order to select the target nodes in each gossip step. Clearly, such
% solution is not scalable, not only due to the large number of nodes that may constitute the view, but also due to
% the cost of maintaining the complete membership up-to-date. To overcome this problem, several gossip protocols
% rely on partial views instead of the complete membership information [20, 9, 11, 23]. A partial view is a small
% subset of the entire system membership that nodes use when selecting gossip peers. These partial views establish
% neighboring associations between nodes, which can be described as a gossip-based overlay network.

% TODO (Talk about the problems it helped solve)

\subsection{Parameters}
\label{subsec:parameters}
% TODO
\begin{description}
    \item[Fanout:]
    \item[Maximum Rounds:]
\end{description}

\subsection{Strategies}
\label{subsec:strategies}
The Gossip Protocol may be executed following different approaches\cite{Karp2000}:
\begin{description}
    \item[Eager push approach:] As soon as a node receive a message for the first time,
        it sends it to \textit{t} randomly selected nodes. This approach consumes a great
        amount of bandwidth, considering it leads to multiple copies of the same messages
        are delivered to each target node.
    \item[Pull approach:] Regularly, nodes inquire each other on new messages they've
        recently receive. If they adquire information about a message they haven't receive
        yet, they will request it expecifically from that node. This approach leads to higher
        values of latency, derivated from the extra round trip needed to obtain the messages.
    \item[Lazy push approach:] When a node receive a message for the first time, it will only
        broadcast to its neighbours a small fraction of the message, a identifier, per example
        a hash of the message. If the neighbour never receive the given identifier it will request
        the rest of the message. As in the pull approach, there will be a higher value of latency.
\end{description}

Besides the diferences in latency and bandwidth previously mentioned, there is another important
distinction between the eager push approach and the pull and lazy push approaches.
Considering that the eager push approach sends the entirety of each message immediatly after
receiving it, the nodes do not need to manitain a copy of these messages, contrarly to the
other two approaches that may need to resend these messages later. This leads to a higher
memory requirement for these approaches\cite{Leitao2012}.

By combining the approaches studied above, we can get better results, obtaining a better
latency/bandwidth tradeof. This are two of the studied combined approaches\cite{Carvalho2007}:
\begin{description}
    \item[Eager push and pull approach:] This method is divided between two distinct phases.
        The first phase consists on using the eager push approach to disseminate messages
        straightly to the nodes in the network. The second phase uses the pull approach to
        recover the lacunas that might have occoured during the first phase of this method.
        This approach reduces the amount of redundancy in comparinse with the eager push
        approach, without decreasing its performance. It will, however, endure a higher level
        of latency due to the pull phase.
    \item[Eager push and lazy push approach:] It is used the eager push approach to a subset of
        nodes. Then it uses the lazy push approach on the remaing subset of nodes to recover
        the lacunas and guarantee the reliable of the method.
\end{description}

\subsection{Tree-based Approaches}
Tree-based broadcasting methods have a small message complexity, however, they are not
particularly resilient to faults. On the other hand, gossip protocols, as mentioned earlier
in section \ref{subsec:history_overview}, are known for their resilience, but have a high
message complexity\cite{Leitao2007Tree}.

In order to obtain a small message complexity and high reliability, it was considered
combining both these methods.

With this protocol we obtain the nodes organized in a tree structure formate, where each node
knows to whom foward its messages. To achieve this structure we have many approaches,
per example the PlumTree protocols:
\begin{description}
    \item[PlumTree protocol] This protocol uses eager push and lazy push gossip, previously explaned in
        the section ref{subsec:strategies}. It separates the nodes in the network in
        two subsets of randomly selected nodes. The first subset of nodes uses the eager push
        protocol to disseminate the messages, while the other uses the lazy push protocol. The
        links that the eager push method uses to propagate the messages are chosen to create
        a randomized broadcast network using a tree-based structure. While the links used
        during the lazy push gossip are used to ensure the reliability of the method when
        nodes fail and potencially heal the broadcast tree when needed\cite{Leitao2007Tree}.
\end{description}

Additionally, in opposition to other gossip protocols, with tree-based gossip the connections
first made by the eager push propagating will remain until it is detected a failure. This will
allow us to use TCP connections, which will provide extra reliability and failure detection.

\subsection{Examples}
Throughout many years there have been proposed numerous gossip-based protocols. During this
section we will discuss some of them:
\begin{description}
    \item[\Gls{SCAMP}:] Contrarly to many other gossip-based protocols, with scamp it is
        proposed that the individual nodes have a randomized partial view of the global
        members in the network, leading to a fully descentralized system. This is quite an
        important advantage for large scale groups, since it requires a significant amount
        of memory and generates a lot of network traffic to maintain the system's overall
        consistency in extensive groups. Additionally, the scalable membership protocol is
        also compelling for its natural increase and reorganization of the partial view of
        the system when new nodes are added to the network. Having this partial view around
        \textit{log n} nodes (being \textit{n} the number of overall nodes in the network)
        \cite{Ganesh2001}.
    \item[\Gls{NeEM}:] One of the biggest problems in most gossip-based protocols is when the
        network gets congested and, subsequentially, the messages get lost. NeEM uses \Gls{TCP}
        to disseminate the messages and resolve this problem, with the usage of its ineherant
        flow and congestion control mechanisms. In order to maintain the protocol's stability,
        NeEM uses a buffer management technique that utilizes different approaches to discard
        messages on overflow. It also includes the knowledge about the messages' types in order
        to ensure that the buffer retains enough space and bandwidth is used to better fit each
        request\cite{Pereira2003}.
    \item[\Gls{CREW}:] Crew is a gossip-based protocol designed to minimize the messages
        dissemination speed. This is acquired by maintaining in cache the information about
        the already established connections, which will reduce the latency of reopening a
        TCP connection\cite{Deshpande2006}.
    \item[Bayeux:]
    \item[Scribe:]
    \item[\Gls{MON}:]
\end{description}


\subsection{Gossip Limitations}
%aka failures

\subsection{Discution}

\section{Wireless Sensor Networks}
\label{sec:wireless_sensor_networks}

\subsection{Definition}

\subsection{Architectures and Strategies}

\subsection{Gossip in WSNs}

\subsection{Applications}
\subsubsection{ZebraNet}
\subsubsection{Wireless Tracking}

\section{Sensors and Arduino}
\label{sec:sensors_and_arduino}

\section{Cows Walking and Eating Habits}
\label{sec:cows}

\section{Existing Collars}
\label{sec:existing_collars}

\section{Summary}
\label{sec:summary}



% not final text, came from chatgpt
% Epidemic protocols, on the other hand, involve nodes sending information to all of their
% neighbors whenever they receive new information. This can be more efficient than gossip
% protocols because nodes only need to send the information once, but it can also be slower
% because it may take longer for the information to reach all nodes in the network.

% \section{Gossip Versus Epidemic Procols}
% \label{sec:gossip_vs_epidemic}
% not final text, came from chatgpt
% Gossip protocols and epidemic protocols are both types of distributed algorithms that are used
% to disseminate information in a network.

% In general, gossip protocols are better suited for situations where it is more important to
% disseminate information quickly, while epidemic protocols are better suited for situations
% where it is more important to ensure that all nodes in the network eventually receive the
% information.